\relax 
\providecommand\hyper@newdestlabel[2]{}
\catcode `"\active 
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\select@language{brazilian}
\@writefile{toc}{\select@language{brazilian}}
\@writefile{lof}{\select@language{brazilian}}
\@writefile{lot}{\select@language{brazilian}}
\@writefile{toc}{\contentsline {section}{\numberline {1}Resultados}{1}{section.1}}
\@writefile{toc}{\contentsline {paragraph}{ As vari\IeC {\'a}veis na parte superior da tabela s\IeC {\~a}o as mesmas que aparecem na tela de estat\IeC {\'\i }sticas do jogador autom\IeC {\'a}tico do EP no modo teste. }{1}{paragraph*.1}}
\@writefile{toc}{\contentsline {paragraph}{ O algoritmo A-star foi rodado s\IeC {\'o} com a heur\IeC {\'\i }stica \texttt  {manhattanDistanceAdmissible}, que \IeC {\'e} uma dist\IeC {\^a}ncia de Manhattan admiss\IeC {\'\i }vel para o problema. No caso descontamos a posi\IeC {\c c}\IeC {\~a}o \texttt  {y} da \texttt  {manhattanDistance}, j\IeC {\'a} que o usu\IeC {\'a}rio n\IeC {\~a}o escolhe ir uma dist\IeC {\^a}ncia para baixo de cada vez. }{2}{paragraph*.6}}
\@writefile{toc}{\contentsline {section}{\numberline {2}Compara\IeC {\c c}\IeC {\~a}o}{2}{section.2}}
\@writefile{toc}{\contentsline {paragraph}{ Agora que temos todos os dados vamos compar\IeC {\'a}-los. Para calcular a tabela abaixo, pegou-se cada inst\IeC {\^a}ncia $i$ de um algoritmo da tabela acima e, para cada outra inst\IeC {\^a}ncia $j$ de qualquer outro algoritmo, fizemos $r_{ij} = \frac  {\DOTSB \sum@ \slimits@ x_i}{\DOTSB \sum@ \slimits@ x_j} = \DOTSB \sum@ \slimits@ \frac  {x_i}{x_j}$, onde $x_i$ \IeC {\'e} a inst\IeC {\^a}ncia $i$ de uma vari\IeC {\'a}vel $x$. Por exemplo, para compararmos o n\IeC {\'u}mero de passos da DFS e BFS, fazemos $r_{dfs,bfs} = \DOTSB \sum@ \slimits@ \frac  {passos_{dfs}}{passos_{bfs}} = \frac  {165}{59} = 2.79$. Para n\IeC {\~a}o termos de escrever v\IeC {\'a}rias tabelas, comparamos um algoritmo com todos e passamos para o pr\IeC {\'o}ximo. Deste modo temos todas as compara\IeC {\c c}\IeC {\~o}es de um jeito mais compacto. \IeC {\'E} f\IeC {\'a}cil de ver que podemos calcular os valores restantes a partir dessa e das tabelas que vimos na se\IeC {\c c}\IeC {\~a}o passada. }{2}{paragraph*.7}}
\@writefile{toc}{\contentsline {paragraph}{ A partir dessa tabela, podemos ver que a DFS faz muitos passos, pode acabar gerando e expandindo muitos n\IeC {\'o}s e tem uma m\IeC {\'e}dia de ramifica\IeC {\c c}\IeC {\~a}o muito similar a cada itera\IeC {\c c}\IeC {\~a}o. Mas tamb\IeC {\'e}m d\IeC {\'a} para se ver que h\IeC {\'a} casos que ela tem uma performance muito melhor que os outros algoritmos, chegando a ter menos n\IeC {\'o}s gerados e expandidos que o A-star. No entanto, podemos ver que, na m\IeC {\'e}dia, a DFS \IeC {\'e} bem pior que o resto dos algoritmos. Al\IeC {\'e}m disso, a DFS \IeC {\'e} sub-\IeC {\'o}tima, o que explica o n\IeC {\'u}mero alto de passos para a solu\IeC {\c c}\IeC {\~a}o final quando comparada aos outros. }{2}{paragraph*.8}}
\@writefile{toc}{\contentsline {paragraph}{ A BFS, BestFS e A-star tem mesmo n\IeC {\'u}mero de passos para a solu\IeC {\c c}\IeC {\~a}o final. Isso \IeC {\'e} por que os tr\IeC {\^e}s algoritmos s\IeC {\~a}o \IeC {\'o}timos (se o custo for uniforme). Eles tamb\IeC {\'e}m tem uma m\IeC {\'e}dia similar de ramifica\IeC {\c c}\IeC {\~a}o, j\IeC {\'a} que a BFS \IeC {\'e}, por defini\IeC {\c c}\IeC {\~a}o, um algoritmo de largura e BestFS e A-star podem voltar atr\IeC {\'a}s e partir de um caminho diferente da qual estava seguindo. Apesar de terem resultados um tanto parecidos, a BFS e BestFS geram e expandem mais em m\IeC {\'e}dia do que o A-star. De fato, se olharmos para a tabela desta se\IeC {\c c}\IeC {\~a}o, pode-se ver que a A-star gera e expande mais ou menos metade dos n\IeC {\'o}s que a BestFS e BFS, enquanto que estas duas tem m\IeC {\'e}dia muito parecida. Isso ocorre por que em um espa\IeC {\c c}o de estados onde o custo \IeC {\'e} uniforme, a BestFS comporta-se de forma parecida a uma BFS. }{2}{paragraph*.9}}
\@writefile{toc}{\contentsline {section}{\numberline {3}Melhorias}{3}{section.3}}
\@writefile{toc}{\contentsline {paragraph}{ A princ\IeC {\'\i }pio, quando foram implementadas, todos os algoritmos geravam e expandiam todos os n\IeC {\'o}s que precisavam sem verificar se aquele n\IeC {\'o} j\IeC {\'a} tinha sido visto em algum caminho anterior. Ao testar a BFS, BestFS e A-star, o tempo para calcular cada solu\IeC {\c c}\IeC {\~a}o era muito grande, travando o browser. Para melhorar a performance, foi inclu\IeC {\'\i }do um \texttt  {Set} para tentar guardar os n\IeC {\'o}s vistos e n\IeC {\~a}o entrarmos em um caminho j\IeC {\'a} percorrido. Inclu\IeC {\'\i }mos esse \texttt  {Set} na BFS, BestFS e A-star para podermos rodar os testes normalmente. Os testes acima foram feitos j\IeC {\'a} com o \texttt  {Set} inclu\IeC {\'\i }do. }{3}{paragraph*.11}}
\@writefile{toc}{\contentsline {paragraph}{ A DFS, no entanto, ainda n\IeC {\~a}o guardava os n\IeC {\'o}s j\IeC {\'a} visitados. A tabela abaixo mostra a DFS com a memoriza\IeC {\c c}\IeC {\~a}o de n\IeC {\'o}s implementada. D\IeC {\'a} para ver que a quantidade de n\IeC {\'o}s gerados e expandidos \IeC {\'e} muito menor, chegando a ser melhor que o A-star em termos de mem\IeC {\'o}ria alocada. Contudo, ele ainda \IeC {\'e} sub-\IeC {\'o}timo. }{3}{paragraph*.12}}
\@writefile{toc}{\contentsline {paragraph}{ Portanto, um jeito de se melhorar os algoritmos \IeC {\'e} memorizar os n\IeC {\'o}s j\IeC {\'a} vistos para n\IeC {\~a}o termos de percorrer um caminho j\IeC {\'a} percorrido. }{3}{paragraph*.14}}
\@writefile{toc}{\contentsline {paragraph}{ Uma outra poss\IeC {\'\i }vel melhoria \IeC {\'e} criar heur\IeC {\'\i }sticas melhores. A heur\IeC {\'\i }stica usada pela BestFS \IeC {\'e} apenas o custo acumulado de cada n\IeC {\'o}. O A-star nas tabelas acima usa uma heur\IeC {\'\i }stica que combina o custo acumulado de cada n\IeC {\'o} e a \texttt  {manhattanDistanceAdmissible}, que \IeC {\'e} apenas o m\IeC {\'o}dulo da diferen\IeC {\c c}a das posi\IeC {\c c}\IeC {\~o}es no eixo horizontal entre o tetramin\IeC {\'o} do n\IeC {\'o} atual com o tetramin\IeC {\'o} meta. }{3}{paragraph*.15}}
\@writefile{toc}{\contentsline {paragraph}{ Para melhorarmos nossa heur\IeC {\'\i }stica do A-star, podemos, al\IeC {\'e}m da dist\IeC {\^a}ncia de Manhattan admiss\IeC {\'\i }vel, incluir o qu\IeC {\~a}o distante da rota\IeC {\c c}\IeC {\~a}o final est\IeC {\'a} o tetramin\IeC {\'o} atual. Portanto, a heur\IeC {\'\i }stica resultante \IeC {\'e}: }{3}{paragraph*.16}}
\@writefile{toc}{\contentsline {paragraph}{ Pela tabela \texttt  {A-star-hr}, pode-se ver que o n\IeC {\'u}mero de n\IeC {\'o}s gerados e expandidos \IeC {\'e} menor que o do A-star original. Al\IeC {\'e}m disso, \texttt  {betterHeuristics} \IeC {\'e} admiss\IeC {\'\i }vel, j\IeC {\'a} que o custo real de se fazer a rota\IeC {\c c}\IeC {\~a}o \IeC {\'e} no m\IeC {\'a}ximo de custo \texttt  {4*Problem.StepCost()}, enquanto que na heur\IeC {\'\i }stica a estimativa \IeC {\'e} de no m\IeC {\'a}ximo 4 com rela\IeC {\c c}\IeC {\~a}o a rota\IeC {\c c}\IeC {\~a}o. }{3}{paragraph*.18}}
