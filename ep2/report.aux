\relax 
\catcode `"\active 
\select@language{brazilian}
\@writefile{toc}{\select@language{brazilian}}
\@writefile{lof}{\select@language{brazilian}}
\@writefile{lot}{\select@language{brazilian}}
\@writefile{toc}{\contentsline {section}{\numberline {1}Regras e fatos}{1}}
\@writefile{toc}{\contentsline {paragraph}{ Neste EP adicionamos regras e fatos das s\IeC {\'e}ries de TV \textit  {Breaking Bad} e \textit  {Game of Thrones}. Temos os seguintes personagens: }{1}}
\@writefile{toc}{\contentsline {paragraph}{ Os predicados foram escolhidos de tal forma que houvesse maior corte de poss\IeC {\'\i }veis personagens durante a consulta. Tamb\IeC {\'e}m evitei colocar predicados desnecess\IeC {\'a}rios salvo alguns por efeito de humor (exemplo: (\texttt  {badger}) \texttt  {is\_stupid}). }{2}}
\@writefile{toc}{\contentsline {section}{\numberline {2}Predicados ideais}{2}}
\@writefile{toc}{\contentsline {paragraph}{ \IeC {\'E} f\IeC {\'a}cil ver que para deixar a consulta o mais eficiente poss\IeC {\'\i }vel devemos sempre tentar dividir as poss\IeC {\'\i }veis respostas em peda\IeC {\c c}os que tenham a menor diferen\IeC {\c c}a poss\IeC {\'\i }vel entre elas. Num mundo ideal, ter\IeC {\'\i }amos todos os personagens com predicados que os dividissem igualmente ao meio, gerando uma resposta a qualquer query em $O(log n)$. Infelizmente no mundo real modelarmos de tal forma \IeC {\'e} imposs\IeC {\'\i }vel, portanto tentamos achar predicados que sejam o mais pr\IeC {\'o}ximos poss\IeC {\'\i }veis a esta "busca bin\IeC {\'a}ria". }{2}}
\@writefile{toc}{\contentsline {paragraph}{ Al\IeC {\'e}m disso, se visualizarmos uma consulta como percorrer os n\IeC {\'o}s da \IeC {\'a}rvore de busca, qualquer n\IeC {\'o} que possua apenas um n\IeC {\'o} filho pode ser descartado por ser irrelevante. H\IeC {\'a} casos no EP em que h\IeC {\'a} n\IeC {\'o}s desnecess\IeC {\'a}rios que poder\IeC {\'\i }amos descartar. }{2}}
\@writefile{toc}{\contentsline {paragraph}{ Um outro ponto importante \IeC {\'e} a ordem em que os predicados aparecem. Ao ordenarmos os predicados por ordem decrescente de uso, estaremos limitando as poss\IeC {\'\i }veis respostas mais rapidamente que se ordenarmos em ordem crescente, j\IeC {\'a} que podemos acabar respondendo perguntas irrelevantes em alguns casos. }{2}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces Note que os n\IeC {\'o}s (predicados) A, E, G e F s\IeC {\~a}o irrelevantes e podemos tira-los. Al\IeC {\'e}m disso o n\IeC {\'o} B deve ser o primeiro predicado a ser perguntado, j\IeC {\'a} que este impacta mais na infer\IeC {\^e}ncia.}}{2}}
\@writefile{toc}{\contentsline {section}{\numberline {3}Prolog}{3}}
\@writefile{toc}{\contentsline {paragraph}{ Prolog \IeC {\'e} uma linguagem bem diferente das quais estou acostumado. Por ser uma linguagem onde lidamos com fatos e regras ao inv\IeC {\'e}s de ser uma linguagem procedimental e imperativa como C, demorou um tempo para acostumar-se. No entanto, \IeC {\'e} uma experi\IeC {\^e}ncia diferente e muito interessante. }{3}}
\@writefile{toc}{\contentsline {section}{\numberline {4}Desempenho}{3}}
\@writefile{toc}{\contentsline {paragraph}{ O programa conseguiu acertar todas as vezes o personagem. No entanto, para certos personagens, se o usu\IeC {\'a}rio erra uma das caracter\IeC {\'\i }sticas dele, o programa imprime como certo. Por exemplo, se acertarmos que \texttt  {flynn\_white} tem as caracter\IeC {\'\i }sticas \texttt  {is\_male}, \texttt  {is\_teenager}, \texttt  {has\_daddy\_issues} mas errarmos e dissermos que ele \texttt  {is\_bold}, o programa dir\IeC {\'a} que o personagem escolhido foi \texttt  {flynn\_white} ao inv\IeC {\'e}s de \texttt  {unknown}. }{3}}
\@writefile{toc}{\contentsline {paragraph}{ Com rela\IeC {\c c}\IeC {\~a}o a perguntas em m\IeC {\'e}dia, o programa conseguia decidir qual o personagem escolhido com cinco perguntas em m\IeC {\'e}dia. Al\IeC {\'e}m disso, \IeC {\'e} interessante notar que os personagens que estavam antes na lista de declara\IeC {\c c}\IeC {\~a}o de regras, foram os que obtiveram menor n\IeC {\'u}mero de perguntas para serem adivinhados. Al\IeC {\'e}m disso, aqueles que possu\IeC {\'\i }am caracter\IeC {\'\i }sticas compartilhadas com um pequeno n\IeC {\'u}mero de personagens tinham maior m\IeC {\'e}dia de perguntas. }{3}}
\@writefile{toc}{\contentsline {section}{\numberline {5}Melhorias}{3}}
\@writefile{toc}{\contentsline {paragraph}{ Como vimos na se\IeC {\c c}\IeC {\~a}o Predicados Ideais e Desempenho, mudar a ordem dos predicados \IeC {\'e} um jeito de melhorarmos a performance do programa. Al\IeC {\'e}m disso, formular predicados que sejam compartilhados com um maior n\IeC {\'u}mero de personagens tamb\IeC {\'e}m, j\IeC {\'a} que podemos excluir aqueles que admitem tal caracter\IeC {\'\i }stica daqueles que n\IeC {\~a}o admitem em maior quantidade, e portanto limitaremos o conjunto de poss\IeC {\'\i }veis respostas mais rapidamente. Outro jeito, mais \IeC {\'o}bvio, de melhorar o programa seria descartar todos os predicados desnecess\IeC {\'a}rios, ou seja, que n\IeC {\~a}o alterem o resultado da query. }{3}}
\@writefile{toc}{\contentsline {section}{\numberline {6}Notas}{3}}
\@writefile{toc}{\contentsline {paragraph}{ Nas linhas 2 e 18 do c\IeC {\'o}digo, tentei melhorar o jeito de se adicionar fatos a base de conhecimento. Minha inten\IeC {\c c}\IeC {\~a}o era colocar todos os personagens numa lista e para cada membro, adicionar o fato: }{3}}
\@writefile{toc}{\contentsline {paragraph}{ Infelizmente meu conhecimento de Prolog \IeC {\'e} muito ruim e isso n\IeC {\~a}o funciona. :( }{3}}
